# **灵魂谐振系统 - 开发流程拆分文档**

## **文档概述**

本文档基于《技能树设计方案》、《节点设计》和《节点实现可行性分析》三份核心设计文档，将整个"灵魂谐振系统"的开发工作拆分为清晰的阶段和任务模块，以便于团队协作和逐步实现。

---

## **开发阶段总览**

整个系统开发分为 **5 个主要阶段**，每个阶段都有明确的交付目标和依赖关系：

```
阶段 0: 基础架构搭建 (Foundation)
    ↓
阶段 1: 核心数据系统 (Core Data)
    ↓
阶段 2: UI 界面系统 (User Interface)
    ↓
阶段 3: 技能节点实现 (Skill Nodes)
    ↓
阶段 4: 网络同步与优化 (Netcode & Polish)
```

---

## **阶段 0: 基础架构搭建**

### **目标**
建立项目的基础代码结构和开发环境，确保团队成员能够正常编译和测试模组。

### **任务清单**

#### **0.1 项目初始化**
- [ ] 创建 tModLoader 1.4.4 模组项目
- [ ] 配置 `build.txt` 和 `description.txt`
- [ ] 建立版本控制（Git）和分支策略
- [ ] 编写团队开发规范文档

#### **0.2 核心类框架**
- [ ] 创建 `SoulResonanceMod.cs` (主 Mod 类)
- [ ] 创建 `SoulPlayer.cs` (继承 ModPlayer)
- [ ] 创建 `SoulSystem.cs` (继承 ModSystem)
- [ ] 创建配置文件结构 (Config)

#### **0.3 开发工具准备**
- [ ] 配置调试热键（用于测试）
- [ ] 创建测试用的作弊命令（快速升级、解锁技能等）
- [ ] 建立日志系统（用于调试网络同步）

**交付标准**: 能够加载模组并在游戏中看到模组名称，无报错。

---

## **阶段 1: 核心数据系统**

### **目标**
实现经验、等级、天赋点、世界谐振等核心数据逻辑，但不包含 UI 和复杂技能效果。

### **任务清单**

#### **1.1 经验与升级系统**
**依据**: 设计方案 §1.1

- [ ] **经验获取逻辑**
  - 实现动态 XP 公式: `XP = (MaxHP/100) × (1 + Defense/10) × (1 + Damage/25)`
  - 在 `GlobalNPC.OnKill` 中计算并授予 XP
  - 实现 Boss XP 排除机制（检查 `npc.boss` 标志）

- [ ] **升级曲线**
  - 实现升级所需 XP 计算: `BaseXP × (CurrentLevel^1.5)`
  - 创建配置选项（BaseXP 和指数可调）
  - 实现升级检测和等级提升逻辑

- [ ] **数据存储**
  - 在 `SoulPlayer` 中定义字段: `currentXP`, `currentLevel`, `talentPoints`, `basicPoints`
  - 实现 `SaveData(TagCompound)` 方法
  - 实现 `LoadData(TagCompound)` 方法（含防御性检查）

**API 依赖**:
- `ModPlayer.SaveData/LoadData`
- `GlobalNPC.OnKill`
- `TagCompound`

#### **1.2 世界谐振系统**
**依据**: 设计方案 §1.2

- [ ] **谐振阶段检测**
  - 创建 `ResonancePhase` 枚举（8 个阶段）
  - 实现 `GetCurrentResonancePhase()` 方法
  - 检测 Boss 击败标志（`NPC.downedBoss1`, `Main.hardMode` 等）

- [ ] **等级上限门控**
  - 实现 `GetMaxLevelCap()` 方法（返回当前阶段的等级上限）
  - 在升级逻辑中添加上限检查
  - 实现"溢出 XP"存储机制（可选）

- [ ] **谐振阶段表**
  - 创建数据结构存储表 1.2.1 的映射关系
  - 实现阶段解锁时的通知/特效（可选）

**测试要点**:
- 在未击败任何 Boss 时，等级应卡在 10 级
- 使用作弊命令击败 Boss 后，等级上限应正确提升

#### **1.3 升级奖励系统**
**依据**: 设计方案 §1.3

- [ ] **天赋点系统**
  - 每 5 级授予 1 天赋点
  - 在 `SoulPlayer` 中维护 `talentPoints` 字段
  - 创建 `unlockedTalents` 列表（存储已解锁的节点 ID）

- [ ] **基础点系统**
  - 每 1 级授予 1 基础点
  - 创建三个属性字段: `soulDamageRank`, `soulDefenseRank`, `soulAgilityRank`
  - 实现边际成本递增逻辑（参考表 1.3.2）

- [ ] **基础点效果应用**
  - 在 `ModifyDamage` 中应用灵魂伤害加成
  - 在 `ModifyDefense` 中应用灵魂防御加成
  - 在 `ModifyMaxRunSpeed` 中应用灵魂敏捷加成

**交付标准**: 
- 击杀怪物能获得 XP 并升级
- 升级时正确授予天赋点和基础点
- 数据能正确保存和加载
- 等级上限受世界谐振限制

---

## **阶段 2: UI 界面系统**

### **目标**
创建"灵魂核心"UI，允许玩家查看状态、分配基础点、解锁天赋节点。

### **任务清单**

#### **2.1 UI 架构设计**
**依据**: 可行性分析 §4.2 方案 1

- [ ] **创建 UI 服务层**
  - 创建 `UIService` 静态类
  - 实现 `ShowSkillBook()` 和 `HideSkillBook()` 方法
  - 管理 UI 可见性状态

- [ ] **创建 UI 系统**
  - 创建 `SoulUISystem : ModSystem`
  - 声明 `UserInterface` 实例
  - 实现 `UpdateUI(GameTime)` 钩子
  - 实现 `ModifyInterfaceLayers` 钩子

#### **2.2 UI 状态与组件**
**依据**: 设计方案 §2.1, §2.2

- [ ] **创建主界面状态**
  - 创建 `SoulCoreUIState : UIState`
  - 实现 `OnInitialize()` 方法
  - 设计放射状布局（8 个同心圆环）

- [ ] **创建可拖拽面板**
  - 创建 `DraggableSoulPanel : UIPanel`
  - 实现 `OnMouseDown/OnMouseUp` 事件
  - 实现拖拽逻辑（含 UI 缩放感知）

- [ ] **创建基础点分配面板**
  - 创建 `BasicPointPanel : UIElement`
  - 显示三项属性和当前等级
  - 实现 "+" 按钮和成本计算
  - 实现点击分配逻辑

- [ ] **创建天赋节点元素**
  - 创建 `TalentNodeElement : UIElement`
  - 实现四种状态的视觉表现（参考表 2.2.1）
    - 已激活 (Active)
    - 可解锁 (Unlockable)
    - 已锁定-点数 (Locked - Points)
    - 已锁定-谐振 (Locked - Attunement)
  - 实现工具提示 (Tooltip)

#### **2.3 UI 交互**
**依据**: 设计方案 §2.3

- [ ] **打开界面**
  - 注册 ModKeybind（默认 'K' 键）
  - 在 `ProcessTriggers` 中检测按键
  - 调用 `UIService.ShowSkillBook()`

- [ ] **天赋点消费**
  - 实现节点点击事件
  - 检查前置条件（等级、点数、前置节点）
  - 扣除天赋点并激活节点
  - 播放激活特效

- [ ] **天赋重置 (Respec)**
  - 创建 NPC 对话选项（向导）
  - 计算重置成本（每点 1 金币）
  - 重置所有天赋点（不重置基础点）

**交付标准**:
- 按 K 键能打开/关闭 UI
- UI 可以拖拽且正确响应缩放
- 能够分配基础点并立即看到属性变化
- 能够解锁天赋节点（即使节点还没有实际效果）

---

## **阶段 3: 技能节点实现**

### **目标**
实现各职业的技能节点效果，从简单的被动属性到复杂的主动机制。

### **开发策略**
按照**难度递增**和**职业优先级**的顺序实现：

1. **优先级 1**: 召唤师（验证"令人愉悦"理念的复杂性）
2. **优先级 2**: 近战和远程（相对简单）
3. **优先级 3**: 法师（涉及法力管理）

### **任务清单**

#### **3.1 被动属性节点**
**依据**: 可行性分析 §2.1
**难度**: ⭐ 低

这是最简单的节点类型，用于验证基础架构。

- [ ] **实现框架**
  - 在 `SoulPlayer` 中创建 `HasTalent(string talentID)` 方法
  - 在各 `Modify...` 钩子中检查天赋并应用加成

- [ ] **示例实现**（每个职业至少 2 个）
  - 近战: 动能打击的伤害加成部分
  - 远程: 战术装填的伤害加成
  - 法师: 法术交织的法力减免
  - 召唤师: 集群战术的穿甲加成

**API 依赖**:
- `ModPlayer.ModifyDamage`
- `ModPlayer.ModifyCritChance`
- `ModPlayer.ModifyDefense`

#### **3.2 事件驱动型节点 (Proc)**
**依据**: 可行性分析 §2.2
**难度**: ⭐⭐ 中

实现"当 X 发生时触发 Y"的机制。

- [ ] **攻击命中触发**
  - 近战: 震荡猛击（暴击时释放冲击波）
  - 远程: 跳弹（子弹反弹）
  - 法师: 传染（减益传播）
  - 召唤师: 忠诚卫士（受伤时仆从反击）

  **实现要点**:
  - 使用 `OnHitNPCWithProj` 钩子
  - 添加 `proj.friendly` 检查（防御性编码）
  - 实现概率判定（使用 `Main.rand.NextFloat()`）

- [ ] **受伤触发**
  - 近战: 钢筋铁骨（受重击时获得防御 Buff）

  **实现要点**:
  - 使用 `PostHurt` 钩子
  - 检查伤害阈值（`damage > player.statLifeMax2 * 0.2f`）
  - 实现冷却时间（使用计时器字段）

**API 依赖**:
- `ModPlayer.OnHitNPCWithProj`
- `ModPlayer.PostHurt`
- `Player.AddBuff`

#### **3.3 主动技能节点**
**依据**: 可行性分析 §2.3
**难度**: ⭐⭐⭐ 中高

实现需要玩家主动触发的技能。

- [ ] **弹幕生成技能**
  - 法师: 天启（召唤流星）
  - 近战: 反击风暴（强化下次攻击）

  **实现步骤**:
  1. 创建 `ModProjectile` 类（如 `ApocalypseMeteor.cs`）
  2. 实现 `SetDefaults()` 设置弹幕属性
  3. 实现 `AI()` 定义行为逻辑
  4. 在技能触发时调用 `Projectile.NewProjectile`
  5. **关键**: 设置 `Owner = Main.myPlayer`

- [ ] **状态改变技能**
  - 近战: 泰坦之御（按住右键格挡）
  - 召唤师: 移形换位（传送仆从）

  **实现要点**:
  - 在 `ProcessTriggers` 中检测按键
  - 使用 `player.controlUseItem` 等检测右键
  - 实现冷却时间管理

**API 依赖**:
- `ModProjectile`
- `Projectile.NewProjectile`
- `ModPlayer.ProcessTriggers`

#### **3.4 复杂机制节点**
**依据**: 节点设计文档
**难度**: ⭐⭐⭐⭐ 高

这些节点需要特殊的状态追踪或复杂逻辑。

- [ ] **连击/堆叠机制**
  - 远程: 链式炮手（连续命中 5 次触发）
  - 召唤师: 鞭炮齐鸣（切换鞭子堆叠效果）

  **实现要点**:
  - 在 `SoulPlayer` 中维护计数器字段
  - 在 `OnHitNPC` 中递增计数
  - 在 `ResetEffects` 中处理超时重置

- [ ] **甜蜜点机制**
  - 近战: 剑刃共鸣（剑刃和剑气同时命中）
  - 召唤师: 鞭法精湛（鞭子尖端命中）

  **实现要点**:
  - 使用 `Projectile.ai[]` 数组存储状态
  - 计算距离和碰撞检测
  - 使用 `Rectangle.Intersects` 检测重叠

- [ ] **召唤物强化 (Bug 绕过)**
  **依据**: 可行性分析 §2.1 召唤物 Bug

  **实现步骤**:
  1. 创建 `GlobalProjectile` 类
  2. 在 `OnSpawn` 中检测召唤物弹幕
  3. 从 `Main.player[proj.owner]` 获取玩家的伤害修饰符
  4. 将修饰符存储在 `proj.ai[]` 或自定义字段中
  5. 在 `PreAI` 中手动应用到 `proj.damage`

**API 依赖**:
- `GlobalProjectile.OnSpawn`
- `GlobalProjectile.PreAI`
- `Projectile.ContinuouslyUpdateDamageStats`

#### **3.5 节点实现优先级表**

| 节点名称 | 职业 | 层级 | 难度 | 优先级 | 备注 |
|---------|------|------|------|--------|------|
| 集群战术 | 召唤师 | T1 | ⭐⭐ | P0 | 验证"主动"理念 |
| 动能打击 | 近战 | T1 | ⭐ | P1 | 简单被动 |
| 战术装填 | 远程 | T1 | ⭐⭐ | P1 | 武器切换检测 |
| 奥术涌动 | 法师 | T1 | ⭐⭐ | P2 | 法力管理 |
| 震荡猛击 | 近战 | T2 | ⭐⭐⭐ | P2 | 自定义弹幕 |
| 鞭炮齐鸣 | 召唤师 | T3 | ⭐⭐⭐⭐ | P3 | 复杂堆叠 |
| 天启 | 法师 | T4 | ⭐⭐⭐⭐ | P4 | 终极技能 |

**交付标准**:
- 每个职业至少实现 2 个 T1 节点
- 至少实现 1 个主动技能节点
- 所有节点在单人模式下正常工作
- 召唤物强化正确应用（绕过 Bug）

---

## **阶段 4: 网络同步与优化**

### **目标**
确保所有系统在多人模式下正确工作，并进行性能优化。

### **任务清单**

#### **4.1 核心数据同步**
**依据**: 可行性分析 §3.1, §4.2 方案 2
**难度**: ⭐⭐⭐⭐⭐ 极高

**关键原则**: 严格遵守"数据-事件-实体"分离模型

- [ ] **ModPlayer 数据同步**

  **客户端 → 服务器**:
  1. 实现 `clientClone(ModPlayer)` 创建快照
  2. 实现 `SendClientChanges(ModPlayer)` 检测变化
  3. 当 `talentPoints` 或 `unlockedTalents` 改变时发送 ModPacket

  **服务器 → 客户端**:
  1. 实现 `SyncPlayer(int toWho, int fromWho, bool newPlayer)`
  2. 将所有关键数据写入 ModPacket
  3. 发送给指定客户端

  **实现示例**:
  ```csharp
  public override void SendClientChanges(ModPlayer clientPlayer) {
      SoulPlayer clone = clientPlayer as SoulPlayer;
      if (talentPoints != clone.talentPoints ||
          unlockedTalents.Count != clone.unlockedTalents.Count) {
          SendTalentDataPacket();
      }
  }
  ```

**API 依赖**:
- `ModPlayer.clientClone`
- `ModPlayer.SendClientChanges`
- `ModPlayer.SyncPlayer`

#### **4.2 事件同步 (ModPacket)**
**依据**: 可行性分析 §3.2

- [ ] **设计消息协议**
  创建消息类型枚举:
  ```csharp
  enum SoulPacketType : byte {
      SyncTalentData = 0,
      CastActiveSkill = 1,
      TriggerVisualEffect = 2,
      // ...
  }
  ```

- [ ] **实现发送逻辑**
  ```csharp
  void SendActiveSkillPacket(byte skillID) {
      ModPacket packet = Mod.GetPacket();
      packet.Write((byte)SoulPacketType.CastActiveSkill);
      packet.Write(skillID);
      packet.Send();
  }
  ```

- [ ] **实现接收逻辑**
  在 `Mod.HandlePacket` 中:
  ```csharp
  public override void HandlePacket(BinaryReader reader, int whoAmI) {
      SoulPacketType msgType = (SoulPacketType)reader.ReadByte();
      switch (msgType) {
          case SoulPacketType.CastActiveSkill:
              byte skillID = reader.ReadByte();
              // 服务器转发给其他客户端
              if (Main.netMode == NetmodeID.Server) {
                  ModPacket packet = GetPacket();
                  packet.Write((byte)msgType);
                  packet.Write(skillID);
                  packet.Send(-1, whoAmI); // 发给所有人，排除发送者
              }
              break;
      }
  }
  ```

**API 依赖**:
- `Mod.GetPacket`
- `ModPacket.Send`
- `Mod.HandlePacket`

#### **4.3 弹幕同步**
**依据**: 可行性分析 §3.3

- [ ] **所有权检查**
  在所有 `Projectile.NewProjectile` 调用中:
  ```csharp
  Projectile.NewProjectile(
      player.GetSource_FromThis(),
      position, velocity,
      type, damage, knockback,
      owner: Main.myPlayer  // 关键！
  );
  ```

- [ ] **状态同步**
  在 `ModProjectile.AI()` 中，当关键变量改变时:
  ```csharp
  if (aiStateChanged) {
      Projectile.netUpdate = true;
  }
  ```

- [ ] **初始同步**
  在弹幕生成后的前几帧:
  ```csharp
  if (Projectile.timeLeft > 3595) { // 前 5 帧
      Projectile.netImportant = true;
  }
  ```

**测试要点**:
- 在多人服务器中测试所有主动技能
- 确保其他玩家能看到弹幕和特效
- 检查伤害是否正确应用

#### **4.4 性能优化**
**依据**: 设计方案 §4.2

- [ ] **UI 性能**
  - UI 只在打开时更新，关闭时停止更新
  - 使用低开销的着色器或贴图（避免粒子系统）
  - 实现 UI 元素的延迟加载

- [ ] **弹幕性能**
  - 避免 "+1 弹幕" 类型的天赋
  - 限制同时存在的技能弹幕数量
  - 使用对象池复用弹幕

- [ ] **计算优化**
  - 缓存昂贵的计算结果（如天赋树遍历）
  - 在 `ResetEffects` 中只重置必要的状态
  - 避免在 `Update` 中进行字符串操作

**交付标准**:
- 在 2-4 人多人游戏中无同步问题
- 所有技能效果对所有玩家可见
- 帧率稳定（60 FPS），无明显卡顿

---

## **阶段 5: 内容完善与平衡**

### **目标**
完成所有职业的全部节点，进行平衡性调整和最终打磨。

### **任务清单**

#### **5.1 节点完整性**
- [ ] 实现所有 T1 节点（4 职业 × 2-3 分支 × 2 节点）
- [ ] 实现所有 T2 节点
- [ ] 实现所有 T3 节点
- [ ] 实现所有 T4 终极节点

#### **5.2 平衡性测试**
**依据**: 节点设计 §2.2

针对每个"守门人" Boss 进行测试:

- [ ] **肉山前 (T1)**
  - 测试玩家能否在 10-20 级击败血肉之墙
  - DPS 应在 100-150 范围（专家模式）
  - 调整 T1 节点数值

- [ ] **困难模式初期 (T2)**
  - 测试 30-40 级对抗世纪之花
  - DPS 应在 400-600 范围
  - 确保难度跳跃可控

- [ ] **困难模式后期 (T3)**
  - 测试 60-70 级对抗月亮领主
  - DPS 应在 2000+ 范围
  - 验证终极技能的"压倒性"感觉

#### **5.3 用户体验优化**
- [ ] 添加升级时的视觉/音效反馈
- [ ] 添加技能激活时的特效
- [ ] 实现天赋树的缩放和平移功能
- [ ] 添加技能说明的本地化支持

#### **5.4 配置与兼容性**
- [ ] 创建完整的 Config 选项
  - XP 倍率调整
  - 升级曲线调整
  - 天赋点获取频率
  - 启用/禁用特定职业分支

- [ ] 测试与主流模组的兼容性
  - Calamity Mod
  - Thorium Mod
  - 其他 RPG 类模组

**交付标准**:
- 所有节点实现完毕且平衡
- 通过完整游戏流程测试（普通+专家模式）
- 无已知 Bug 或崩溃
- 用户体验流畅

---

## **开发时间估算**

基于 1-2 名熟练开发者的工作量估算：

| 阶段 | 预计时间 | 关键风险 |
|------|---------|---------|
| 阶段 0: 基础架构 | 1-2 周 | 环境配置问题 |
| 阶段 1: 核心数据 | 2-3 周 | 升级曲线平衡 |
| 阶段 2: UI 系统 | 3-4 周 | UI 样板代码繁琐 |
| 阶段 3: 技能节点 | 4-6 周 | 复杂机制实现 |
| 阶段 4: 网络同步 | 2-3 周 | 网络同步 Bug |
| 阶段 5: 完善平衡 | 2-3 周 | 平衡性调整迭代 |
| **总计** | **14-21 周** | **约 3.5-5 个月** |

---

## **关键开发规范**

### **代码规范**
1. **命名约定**:
   - 类名: `PascalCase`
   - 字段: `camelCase`
   - 常量: `UPPER_SNAKE_CASE`

2. **注释要求**:
   - 所有公共方法必须有 XML 文档注释
   - 复杂逻辑必须有行内注释
   - 网络同步代码必须注明数据流向

3. **防御性编码**:
   - 所有 `LoadData` 必须检查键是否存在
   - 所有 `OnHitNPC` 必须检查 `proj.friendly`
   - 所有除法必须检查除数非零

### **测试规范**
1. **单人测试**: 每个功能完成后立即测试
2. **多人测试**: 每个阶段完成后进行
3. **性能测试**: 使用 tModLoader 的性能分析工具
4. **兼容性测试**: 在干净环境和模组环境中分别测试

### **版本控制规范**
1. **分支策略**:
   - `main`: 稳定版本
   - `dev`: 开发分支
   - `feature/xxx`: 功能分支

2. **提交规范**:
   - 格式: `[阶段] 简短描述`
   - 示例: `[阶段1] 实现经验获取逻辑`

---

## **附录: API 快速参考**

### **核心类**
- `ModPlayer`: 玩家数据和逻辑
- `ModSystem`: 全局系统和 UI 管理
- `ModProjectile`: 自定义弹幕
- `GlobalNPC`: 修改所有 NPC 行为
- `GlobalProjectile`: 修改所有弹幕行为

### **关键钩子**
- `SaveData/LoadData`: 数据持久化
- `ModifyDamage/ModifyDefense`: 属性修改
- `OnHitNPCWithProj`: 攻击命中
- `PostHurt`: 受到伤害
- `ProcessTriggers`: 按键检测
- `ModifyInterfaceLayers`: UI 注册

### **网络同步**
- `clientClone/SendClientChanges/SyncPlayer`: ModPlayer 同步
- `Mod.GetPacket/HandlePacket`: 自定义消息
- `Projectile.netUpdate`: 弹幕同步

---

## **总结**

本开发流程文档将"灵魂谐振系统"拆分为 5 个清晰的阶段，每个阶段都有明确的目标、任务清单和交付标准。开发团队应：

1. **严格按阶段顺序开发**，不要跳过基础阶段
2. **优先实现网络同步框架**（阶段 4），避免后期重构
3. **采用"UI 服务"和"混合网络模型"架构**，确保代码可维护性
4. **遵循防御性编码原则**，特别是在数据加载和网络同步部分
5. **持续进行平衡性测试**，确保系统符合设计目标

预计整个系统的开发周期为 **3.5-5 个月**，其中网络同步和 UI 系统是最大的技术挑战。

